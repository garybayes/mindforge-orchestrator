Task Assistant 1.0 — Technical Design Document
1. Overview
1.1 Purpose

Task Assistant 1.0 is a GitHub-native automation system that manages:

Issue & track state machines

Milestones & sprints

Repo hygiene (labels, stale issues, missing metadata)

Telemetry collection → dashboard.json → GitHub Pages dashboard

Self-tests and diagnostics for the automation itself

It is implemented as:

A GitHub App (Task Assistant) +

A set of reusable GitHub Actions workflows +

Config files & telemetry conventions within each repository.

This document defines the technical design for Task Assistant 1.0, focused on single-repo operation (multi-repo comes later with Codex SaaS).

1.2 Goals

Provide a repeatable, installable “Task Assistant” bundle any repo can adopt.

Enforce consistent track & milestone workflows via a state machine.

Maintain normalized telemetry JSON for dashboards.

Detect and optionally self-heal hygiene problems:

Bad / missing labels

Missing milestones

Mis-assigned tracks

Stale issues

Provide a diagnostics & self-test framework so the automation can verify itself.

1.3 Non-Goals (for 1.0)

No multi-repo / org-wide SaaS UI (that’s Codex SaaS 1.0).

No billing or subscription logic.

No external database; all state is GitHub (issues, labels, workflows, telemetry files).

No Slack/Teams notifications (optional extension later).

1.4 Feature Scope Summary (1.0)

Configuration

.github/task-assistant.yml with tracks, milestones, thresholds.

Optional repo variables / secrets.

Automation

Issue lifecycle hooks on create/update/label/milestone.

Nightly hygiene sweep.

Stale detection & escalation.

Track label normalization.

Milestone enforcement.

Telemetry

Event JSONs written under telemetry/.

Aggregation into dashboard/dashboard.json.

Static dashboard UI from GitHub Pages using dashboard/index.html.

Diagnostics

Self-test workflow (task-assistant-self-test.yml).

Diagnostics output in telemetry/diagnostics.json.

2. System Context & Architecture
2.1 High-Level Architecture

Logical components:

Task Assistant GitHub App

Handles app installation.

Provides app identity & permissions.

Receives webhooks (for future SaaS; 1.0 mostly uses Actions).

Repo-Level Workflows (Core of Task Assistant 1.0)

Trigger on:

issue events

milestone events

schedule (e.g., nightly)

workflow_dispatch (manual)

Call Task Assistant’s logic (containerized or composite actions).

Config & Rules

.github/task-assistant.yml — single source of truth for:

Tracks

Milestone patterns

Stale thresholds

Escalation rules

Dashboard config.

Telemetry & Dashboard Files

telemetry/*.json — event logs.

dashboard/dashboard.json — aggregated snapshot.

gh-pages branch hosts dashboard/index.html.

Dashboard Frontend

Static HTML/JS bundle (generated by a build step).

Reads dashboard/dashboard.json.

For Task Assistant 1.0, all persistent state is GitHub objects + JSON files in the repo.

3. Key Use Cases
3.1 Issue Created / Updated

Scenario

Developer creates or edits an issue.

Task Assistant validates:

Required labels present.

Track label is valid.

Milestone is consistent with configured sprint scheme.

Task Assistant:

Fixes issues (e.g., applies default milestone).

Writes telemetry event.

Optionally adds a comment if manual action is needed.

3.2 Nightly Hygiene Sweep

Scenario

Scheduled workflow runs nightly.

Task Assistant:

Scans all open issues.

Detects stale issues.

Applies escalation labels / milestones.

Validates label & milestone consistency.

Writes telemetry & diagnostics.

Dashboard.json is regenerated.

3.3 Sprint Rollover

Scenario

At sprint end, a maintainer runs a manual workflow_dispatch (or scheduled job).

Task Assistant:

Closes sprint milestone.

Creates next sprint milestone.

Moves unfinished issues to new sprint.

Writes events & updates dashboard.

3.4 Self-Test / Diagnostics

Scenario

Maintainer runs task-assistant-self-test.yml.

Task Assistant:

Checks required variables.

Verifies label sets & milestone patterns.

Confirms telemetry & dashboard write permissions.

Outputs pass/fail diagnostics.

4. Detailed Component Design
4.1 Configuration: .github/task-assistant.yml

Location

.github/task-assistant.yml


Schema (v1.0)

version: 1

tracks:
  - id: sprint
    label: track/sprint
    default_milestone_pattern: "Sprint {major}.{minor}"
  - id: backlog
    label: track/backlog
  - id: support
    label: track/support
  - id: ops
    label: track/ops

milestones:
  sprint_pattern: "Sprint {major}.{minor}"
  internal_milestone_label: "Codex Internal"
  default_sprint_duration_days: 14

stale:
  enabled: true
  days_until_stale: 14
  days_until_close: 30
  stale_label: "state/stale"
  exclude_labels:
    - "state/pinned"
    - "priority/high"

telemetry:
  enabled: true
  path: "telemetry"
  dashboard_path: "dashboard/dashboard.json"

self_healing:
  enabled: true
  normalize_labels: true
  fix_missing_track: true
  fix_missing_milestone: true


Note: The design assumes the config is schema-validated before execution.

4.2 GitHub App: Task Assistant

For 1.0, the App is primarily a wrapper identity & future-proofing, while most business logic runs via repo workflows. However, we define permissions now to avoid migration pain later.

Permissions (minimum)

Repository contents: read / write

Issues: read / write

Metadata: read

Pull requests: read (for future use)

Actions: read (audit & telemetry)

Projects (classic): read / write (if used)

Workflows: read / write (optional)

Webhooks subscribed

issues

issue_comment

milestone

label

workflow_run

(push can be added later for deep telemetry)

Behavior in 1.0

1.0 can function without external webhook handling; the App primarily supports:

Authentication for any future cloud service.

Branding and configuration entry point.

4.3 Workflows

We define a minimal set of workflows that are Task Assistant 1.0.

4.3.1 task-assistant-issue-events.yml

Trigger

on:
  issues:
    types: [opened, edited, labeled, unlabeled, milestoned, demilestoned, reopened]


Responsibilities

Load .github/task-assistant.yml.

Classify issue into track.

Validate:

Required track label present.

Milestone matches sprint pattern (if applicable).

Self-healing if enabled:

Apply track/* labels.

Apply default milestone for track/sprint.

Emit telemetry event:

telemetry/events/{issue_number}-{timestamp}.json.

Implementation

As a composite GitHub Action or container action:

actions/task-assistant-issue-processor@v1.

4.3.2 task-assistant-nightly-sweep.yml

Trigger

on:
  schedule:
    - cron: "0 2 * * *"  # 2 AM UTC


Responsibilities

List all open issues.

For each issue:

Check last updated date.

Apply state/stale label if older than days_until_stale.

Optionally comment on issue when becoming stale.

Close automatically if older than days_until_close and still stale.

Validate track / milestone consistency.

Emit telemetry summary:

telemetry/sweeps/{date}.json.

Regenerate dashboard/dashboard.json.

4.3.3 task-assistant-dashboard-build.yml

Trigger

on:
  workflow_dispatch:
  schedule:
    - cron: "0 * * * *"  # hourly, or less frequent


Responsibilities

Read all relevant telemetry files (events, sweeps, diagnostics).

Aggregate:

Issue counts per track.

Velocity estimates (issues closed per sprint / per week).

Stale counts.

Label/milestone hygiene statistics.

Produce dashboard/dashboard.json with normalized schema (see §5.2).

Optionally commit dashboard/dashboard.json to:

gh-pages branch OR

dashboard folder in default branch (depending on deployment mode).

4.3.4 task-assistant-self-test.yml

Trigger

on:
  workflow_dispatch:


Responsibilities

Validate:

.github/task-assistant.yml exists & parses.

Required labels exist (e.g., track/sprint, state/stale).

Milestone pattern matches existing milestones.

Required repo variables/secrets (if any).

Write permissions to telemetry/ & dashboard/.

Emit diagnostics:

telemetry/diagnostics.json.

Outputs

Workflow success/failure.

Summary via ::notice:: and ::error:: annotations.

4.4 Directory Structure Conventions

Primary repo structure for Task Assistant 1.0:

.github/
  task-assistant.yml
  workflows/
    task-assistant-issue-events.yml
    task-assistant-nightly-sweep.yml
    task-assistant-dashboard-build.yml
    task-assistant-self-test.yml

telemetry/
  events/
    001-2025-12-01T00-00-00Z.json
    ...
  sweeps/
    2025-12-01.json
  diagnostics.json

dashboard/
  dashboard.json
  index.html  # (optional, or only on gh-pages)

5. Data & Telemetry Model
5.1 Telemetry Event Schema

File location

telemetry/events/{issue_number}-{ISO8601}.json


Schema

{
  "version": 1,
  "type": "issue_event",
  "generated_at": "2025-12-07T01:23:45Z",
  "repository": "owner/repo",
  "issue": {
    "id": 123456789,
    "number": 42,
    "title": "Example issue",
    "url": "https://github.com/owner/repo/issues/42",
    "state": "open",
    "labels": ["track/sprint", "priority/medium"],
    "milestone": "Sprint 1.2",
    "created_at": "2025-12-06T10:00:00Z",
    "updated_at": "2025-12-06T11:00:00Z"
  },
  "classification": {
    "track": "sprint",
    "is_stale": false,
    "is_valid": true,
    "violations": []
  },
  "actions_taken": [
    "applied_label:track/sprint",
    "applied_milestone:Sprint 1.2"
  ]
}

5.2 Dashboard Snapshot Schema

File

dashboard/dashboard.json


Schema (v1.0)

{
  "version": 1,
  "generated_at": "2025-12-07T02:00:00Z",
  "repository": "owner/repo",
  "summary": {
    "open_issues": 120,
    "closed_issues_last_7d": 34,
    "stale_issues": 12,
    "avg_issue_age_days": 9.3
  },
  "tracks": [
    {
      "id": "sprint",
      "label": "track/sprint",
      "open_issues": 56,
      "stale_issues": 4,
      "throughput_last_7d": 18
    },
    {
      "id": "backlog",
      "label": "track/backlog",
      "open_issues": 40,
      "stale_issues": 6,
      "throughput_last_7d": 10
    }
  ],
  "sprints": [
    {
      "name": "Sprint 1.2",
      "milestone_id": 987654321,
      "state": "open",
      "start_date": "2025-12-01",
      "end_date": "2025-12-14",
      "issues_total": 30,
      "issues_closed": 12,
      "issues_open": 18,
      "burn_down_series": [
        { "date": "2025-12-01", "remaining": 30 },
        { "date": "2025-12-02", "remaining": 28 }
      ]
    }
  ],
  "hygiene": {
    "missing_track_label": 3,
    "missing_milestone": 5,
    "invalid_labels": 2
  },
  "automation_health": {
    "last_nightly_sweep": "2025-12-07T02:00:00Z",
    "last_self_test_status": "success",
    "workflow_failures_last_7d": 1
  }
}

5.3 Diagnostics Schema

File

telemetry/diagnostics.json


Schema

{
  "version": 1,
  "generated_at": "2025-12-07T02:10:00Z",
  "status": "warning",
  "checks": [
    {
      "id": "config-file-present",
      "status": "pass",
      "message": ".github/task-assistant.yml exists"
    },
    {
      "id": "required-labels-exist",
      "status": "fail",
      "message": "Missing label: track/support"
    },
    {
      "id": "telemetry-write-permission",
      "status": "pass",
      "message": "Able to create files in telemetry/"
    }
  ]
}

6. Key Flows & Sequences
6.1 Issue Created / Edited (Happy Path)

Trigger: issues.opened or issues.edited.

task-assistant-issue-events.yml runs:

Step 1: Checkout repo.

Step 2: Load .github/task-assistant.yml.

Step 3: Determine track:

If track/* present → use that.

Else, apply default based on config rules (e.g., sprint).

Step 4: Check milestone:

If track/sprint and no milestone → create or assign current sprint milestone.

Step 5: Apply missing labels / milestone via GitHub API.

Step 6: Generate telemetry event JSON.

Result:

Issue is correctly labeled & milestone-assigned.

Telemetry event stored.

6.2 Nightly Sweep

Trigger: schedule at 02:00 UTC.

Workflow:

Step 1: Fetch all open issues (paged).

Step 2: For each issue:

Calculate age since last update.

Flag as stale if > days_until_stale.

Close if stale and older than days_until_close and not in excluded labels.

Validate track/milestone rules.

Record actions taken.

Step 3: Write sweep summary JSON.

Step 4: Rebuild dashboard/dashboard.json.

Result:

Stale issues labeled/closed.

Dashboard updated.

Hygiene metrics updated.

6.3 Self-Test

Trigger: maintainer runs workflow_dispatch.

Workflow:

Step 1: Validate configuration file.

Step 2: Verify required labels exist.

Step 3: Verify telemetry & dashboard paths exist or can be created.

Step 4: Optionally run a “dry-run” classification against a sample issue.

Step 5: Write diagnostics JSON.

Result:

Quick signal whether Task Assistant is correctly configured.

7. Non-Functional Requirements
7.1 Performance

Target: Nightly sweep on repos up to ~2,000 open issues should complete within 15 minutes.

Pagination must be used for listing issues.

Batch operations where possible (but GitHub API is mostly single-resource; we minimize calls via filtering).

7.2 Reliability

Workflows must handle transient API failures:

Retry on 5xx responses.

Backoff when rate-limited.

Telemetry writes should:

Fail gracefully (log error in workflow) if file commit fails.

Self-test provides a quick signal if something breaks.

7.3 Security

No secrets beyond:

GITHUB_TOKEN (GitHub-provided).

Any optional Task Assistant-specific tokens (v2+).

No external data stores in 1.0.

No PII stored; issue titles are stored in telemetry but can be truncated by configuration if needed.

7.4 Maintainability

Task Assistant logic should be:

Implemented in a single reusable action (e.g., task-assistant-core).

Well-typed (TypeScript if Node-based).

Config schema documented & versioned.

8. Testing Strategy
8.1 Unit Tests

Core classification logic.

Stale detection logic.

Milestone pattern utilities.

Telemetry serializers.

8.2 Integration Tests (Local)

Use act or similar to simulate:

Issue events.

Scheduled workflows.

Confirm telemetry and dashboard files generated correctly.

8.3 GitHub Test Repo

Maintain a dedicated task-assistant-sandbox repo:

With sample config.

With controlled sets of issues & labels.

Run workflows on pushes to main.

8.4 Self-Test Workflow

task-assistant-self-test.yml acts as a smoke test:

Config valid.

Labels present.

Telemetry writable.

9. Migration Plan from Existing Codex Setup

Phase 1: Side-by-side

Introduce .github/task-assistant.yml without removing old configs.

Add new workflows with Task Assistant naming.

Keep old telemetry structure but add new fields required by 1.0.

Phase 2: Consolidation

Migrate telemetry file naming to telemetry/events/ and telemetry/sweeps/.

Switch dashboard/dashboard.json to the new schema.

Phase 3: Deprecation

Remove legacy workflows.

Remove obsolete variables / configs.

10. Future Extensions Beyond 1.0

Multi-repo Task Assistant via a SaaS.

Org-wide dashboards.

Integration with Slack/Teams.

“Playbooks” for sprint planning and release readiness.

Inferred track rules (NLP on issue titles).

Pluggable rule engine (user-defined rules).

11. Actionable Next Steps

Create Task Assistant config file schema and add JSON Schema validation.

Implement task-assistant-core action (Node/TypeScript or Python):

Config parsing.

Classification.

Stale detection.

Telemetry writing.

Draft the four workflows:

task-assistant-issue-events.yml

task-assistant-nightly-sweep.yml

task-assistant-dashboard-build.yml

task-assistant-self-test.yml

Align your existing Task Assistant telemetry & dashboard to the schemas in §5.

Set up a dedicated test repo and start dry-runs.
